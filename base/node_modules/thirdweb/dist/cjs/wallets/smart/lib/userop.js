"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForUserOpReceipt = waitForUserOpReceipt;
exports.createUnsignedUserOp = createUnsignedUserOp;
exports.signUserOp = signUserOp;
const viem_1 = require("viem");
const fee_data_js_1 = require("../../../gas/fee-data.js");
const encode_js_1 = require("../../../transaction/actions/encode.js");
const encodeAbiParameters_js_1 = require("../../../utils/abi/encodeAbiParameters.js");
const is_contract_deployed_js_1 = require("../../../utils/bytecode/is-contract-deployed.js");
const to_bytes_js_1 = require("../../../utils/encoding/to-bytes.js");
const fetch_js_1 = require("../../../utils/fetch.js");
const keccak256_js_1 = require("../../../utils/hashing/keccak256.js");
const resolve_promised_value_js_1 = require("../../../utils/promise/resolve-promised-value.js");
const bundler_js_1 = require("./bundler.js");
const calls_js_1 = require("./calls.js");
const constants_js_1 = require("./constants.js");
const paymaster_js_1 = require("./paymaster.js");
const utils_js_1 = require("./utils.js");
/**
 * Wait for the user operation to be mined.
 * @param args - The options and user operation hash
 * @returns - The transaction receipt
 *
 * @example
 * ```ts
 * import { waitForUserOpReceipt } from "thirdweb/wallets/smart";
 *
 * const receipt = await waitForUserOpReceipt({
 *  chain,
 *  client,
 *  userOpHash,
 * });
 * ```
 * @walletUtils
 */
async function waitForUserOpReceipt(args) {
    const timeout = args.timeoutMs || 120000; // 2mins
    const interval = args.intervalMs || 1000; // 1s
    const endtime = Date.now() + timeout;
    while (Date.now() < endtime) {
        const userOpReceipt = await (0, bundler_js_1.getUserOpReceipt)(args);
        if (userOpReceipt) {
            return userOpReceipt;
        }
        await new Promise((resolve) => setTimeout(resolve, interval));
    }
    throw new Error("Timeout waiting for userOp to be mined");
}
/**
 * Creates an unsigned user operation from a prepared transaction.
 * @param args - The prepared transaction and options
 * @returns - The unsigned user operation
 * @example
 * ```ts
 * import { createUnsignedUserOp } from "thirdweb/wallets/smart";
 *
 * const transaction = prepareContractCall(...);
 *
 * const userOp = await createUnsignedUserOp({
 *  transaction,
 *  options,
 * });
 * ```
 * @walletUtils
 */
async function createUnsignedUserOp(args) {
    const { transaction: executeTx, options } = args;
    const isDeployed = await (0, is_contract_deployed_js_1.isContractDeployed)(options.accountContract);
    const initCode = isDeployed ? "0x" : await getAccountInitCode(options);
    const callData = await (0, encode_js_1.encode)(executeTx);
    let { maxFeePerGas, maxPriorityFeePerGas } = executeTx;
    const bundlerUrl = options.overrides?.bundlerUrl ?? (0, constants_js_1.getDefaultBundlerUrl)(options.chain);
    if ((0, fetch_js_1.isThirdwebUrl)(bundlerUrl)) {
        // get gas prices from bundler
        const bundlerGasPrice = await (0, bundler_js_1.getUserOpGasPrice)({
            options,
        });
        maxFeePerGas = bundlerGasPrice.maxFeePerGas;
        maxPriorityFeePerGas = bundlerGasPrice.maxPriorityFeePerGas;
    }
    else {
        // Check for explicity values
        const [resolvedMaxFeePerGas, resolvedMaxPriorityFeePerGas] = await Promise.all([
            (0, resolve_promised_value_js_1.resolvePromisedValue)(maxFeePerGas),
            (0, resolve_promised_value_js_1.resolvePromisedValue)(maxPriorityFeePerGas),
        ]);
        if (resolvedMaxFeePerGas && resolvedMaxPriorityFeePerGas) {
            // Save a network call if the values are provided
            maxFeePerGas = resolvedMaxFeePerGas;
            maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas;
        }
        else {
            // Fallback to RPC gas prices if no explicit values provided
            const feeData = await (0, fee_data_js_1.getDefaultGasOverrides)(options.client, options.chain);
            // Still check for explicit values in case one is provided and not the other
            maxPriorityFeePerGas =
                resolvedMaxPriorityFeePerGas ?? feeData.maxPriorityFeePerGas ?? 0n;
            maxFeePerGas = resolvedMaxFeePerGas ?? feeData.maxFeePerGas ?? 0n;
        }
    }
    // const nonce = BigInt(transaction.nonce || randomNonce());
    const nonce = (0, utils_js_1.randomNonce)(); // FIXME getNonce should be overrideable by the wallet
    const partialOp = {
        sender: options.accountContract.address,
        nonce,
        initCode,
        callData,
        maxFeePerGas,
        maxPriorityFeePerGas,
        callGasLimit: 0n,
        verificationGasLimit: 0n,
        preVerificationGas: 0n,
        paymasterAndData: "0x",
        signature: constants_js_1.DUMMY_SIGNATURE,
    };
    if (options.sponsorGas) {
        const paymasterResult = await (0, paymaster_js_1.getPaymasterAndData)({
            userOp: partialOp,
            options,
        });
        const paymasterAndData = paymasterResult.paymasterAndData;
        if (paymasterAndData && paymasterAndData !== "0x") {
            partialOp.paymasterAndData = paymasterAndData;
        }
        // paymaster can have the gas limits in the response
        if (paymasterResult.callGasLimit &&
            paymasterResult.verificationGasLimit &&
            paymasterResult.preVerificationGas) {
            partialOp.callGasLimit = paymasterResult.callGasLimit;
            partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;
            partialOp.preVerificationGas = paymasterResult.preVerificationGas;
        }
        else {
            // otherwise fallback to bundler for gas limits
            const estimates = await (0, bundler_js_1.estimateUserOpGas)({
                userOp: partialOp,
                options,
            });
            partialOp.callGasLimit = estimates.callGasLimit;
            partialOp.verificationGasLimit = estimates.verificationGasLimit;
            partialOp.preVerificationGas = estimates.preVerificationGas;
            // need paymaster to re-sign after estimates
            if (paymasterAndData && paymasterAndData !== "0x") {
                const paymasterResult2 = await (0, paymaster_js_1.getPaymasterAndData)({
                    userOp: partialOp,
                    options,
                });
                if (paymasterResult2.paymasterAndData &&
                    paymasterResult2.paymasterAndData !== "0x") {
                    partialOp.paymasterAndData = paymasterResult2.paymasterAndData;
                }
            }
        }
    }
    else {
        // not gasless, so we just need to estimate gas limits
        const estimates = await (0, bundler_js_1.estimateUserOpGas)({
            userOp: partialOp,
            options,
        });
        partialOp.callGasLimit = estimates.callGasLimit;
        partialOp.verificationGasLimit = estimates.verificationGasLimit;
        partialOp.preVerificationGas = estimates.preVerificationGas;
    }
    return {
        ...partialOp,
        signature: "0x",
    };
}
/**
 * Sign a user operation.
 * @param userOp - The UserOperation to sign (with signature field ignored)
 * @returns - The user operation with the signature field populated
 * @example
 * ```ts
 * import { signUserOp } from "thirdweb/wallets/smart";
 *
 * const userOp = createUnsignedUserOp(...);
 *
 * const signedUserOp = await signUserOp({
 *  userOp,
 *  options,
 * });
 * ```
 * @walletUtils
 */
async function signUserOp(args) {
    const { userOp, options } = args;
    const userOpHash = getUserOpHash({
        userOp,
        entryPoint: options.overrides?.entrypointAddress || constants_js_1.ENTRYPOINT_ADDRESS_v0_6,
        chainId: options.chain.id,
    });
    if (options.personalAccount.signMessage) {
        const signature = await options.personalAccount.signMessage({
            message: {
                raw: (0, to_bytes_js_1.hexToBytes)(userOpHash),
            },
        });
        return {
            ...userOp,
            signature,
        };
    }
    throw new Error("signMessage not implemented in signingAccount");
}
async function getAccountInitCode(options) {
    const { factoryContract } = options;
    const deployTx = (0, calls_js_1.prepareCreateAccount)({
        factoryContract,
        options,
    });
    return (0, viem_1.concat)([factoryContract.address, await (0, encode_js_1.encode)(deployTx)]);
}
/**
 * Get the hash of a user operation.
 * @param args - The user operation, entrypoint address, and chain ID
 * @returns - The hash of the user operation
 * @walletUtils
 */
function getUserOpHash(args) {
    const { userOp, entryPoint, chainId } = args;
    const hashedInitCode = (0, keccak256_js_1.keccak256)(userOp.initCode);
    const hashedCallData = (0, keccak256_js_1.keccak256)(userOp.callData);
    const hashedPaymasterAndData = (0, keccak256_js_1.keccak256)(userOp.paymasterAndData);
    const packedUserOp = (0, encodeAbiParameters_js_1.encodeAbiParameters)([
        { type: "address" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "bytes32" },
    ], [
        userOp.sender,
        userOp.nonce,
        hashedInitCode,
        hashedCallData,
        userOp.callGasLimit,
        userOp.verificationGasLimit,
        userOp.preVerificationGas,
        userOp.maxFeePerGas,
        userOp.maxPriorityFeePerGas,
        hashedPaymasterAndData,
    ]);
    const encoded = (0, encodeAbiParameters_js_1.encodeAbiParameters)([{ type: "bytes32" }, { type: "address" }, { type: "uint256" }], [(0, keccak256_js_1.keccak256)(packedUserOp), entryPoint, BigInt(chainId)]);
    return (0, keccak256_js_1.keccak256)(encoded);
}
//# sourceMappingURL=userop.js.map